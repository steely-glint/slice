/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.ipseorama.slice.stun;

import com.phono.srtplight.Log;
import java.net.InetSocketAddress;
import java.util.ArrayList;

public class StunBindingRequest extends StunPacket {

    public StunBindingRequest(short mtype, Integer fingerprint, ArrayList<StunAttribute> attributes, byte[] messageIntegrity, InetSocketAddress near) {
        super(mtype, fingerprint, attributes, messageIntegrity, near);
    }

    public StunBindingRequest() {
        super((short) 0x0001);
    }

    public boolean hasRequiredIceAttributes() {
        String reqAttrs[] = {"FINGERPRINT", "MESSAGE-INTEGRITY", "PRIORITY", "USERNAME"};
        for (String ra : reqAttrs) {
            if (!hasAttribute(this._attributes, ra)) {
                Log.debug("missing Attribute " + ra);
                return false;
            }
        }
        return true;
    }

    public Long getPriority() {
        Long ret = null;
        StunAttribute priA = this.getAttributeByName("PRIORITY");
        if (priA != null) {
            ret = (long) priA.getInt();
        }
        return ret;
    }

    /*
    6.1.3.  STUN Server Procedures

   An agent MUST be prepared to receive a Binding request on the base of
   each candidate it included in its most recent candidate exchange.
   This requirement holds even if the peer is a lite implementation.

   The agent MUST use the short-term credential mechanism (i.e., the
   MESSAGE-INTEGRITY attribute) to authenticate the request and perform
   a message integrity check.  Likewise, the short-term credential
   mechanism MUST be used for the response.  The agent MUST consider the
   username to be valid if it consists of two values separated by a
   colon, where the first value is equal to the username fragment
   generated by the agent in an candidate exchange for a session in-
   progress. 
     */
    public boolean isUser(String nearusername) {
        boolean ret = false;
        StunAttribute priA = this.getAttributeByName("USERNAME");
        if (priA != null) {
            String u2 = priA.getString();
            if (u2 != null) {
                String bits[] = u2.split(":");
                if (bits.length == 2) {
                    ret = bits[0].equals(nearusername);
                }
            }
        }
        return ret;
    }

    String flipU() {
        String ret = null;
        StunAttribute priA = this.getAttributeByName("USERNAME");
        if (priA != null) {
            String u2 = priA.getString();
            if (u2 != null) {
                String bits[] = u2.split(":");
                if (bits.length == 2) {
                    ret = bits[1] + ":" + bits[0];
                }
            }
        }
        return ret;
    }

    String getUserName() {
        String ret = null;
        StunAttribute priA = this.getAttributeByName("USERNAME");
        if (priA != null) {
            ret = priA.getString();
        }
        return ret;
    }

    public boolean localAgentHasBiggerTieBreaker(long near,String aname) {
        boolean ret = false;
        StunAttribute ira = this.getAttributeByName(aname);
        long far = ira.getLong();

        // there are no unsigned longs,
        // so we shift the top bit downwards
        // losing a bit of precison        
        long farb = far >>> 1;
        long nearb = near >>> 1;
        if (farb == nearb) { // in the staggeringly unlikey situation that the lowest bit is the only difference
            ret = (near & 1) > (far & 1); // compare the original lowest bits
        } else {
            ret = nearb > farb; // otherwise we compare the 63 bit values.
        }
        return ret;
    }
}
